# MASP validity predicate (VP)

## Introduction and approach
How to adapt a protocol that was originally designed for an UTXO-like execution model into a account based architecture?
The approach chosen for Namada is having the MASP implemented as Namada account with a validity predicate which handles
the verification of shielded transactions, and then have all the notes data owned by such account. Hence the MASP address
holds all the shielded assets.
Similarly to zcash, the asset balance of the shielded pool itself is transparent - that is, from the transparent
perspective, the MASP is just an account holding assets.

The MASP VP has the following functions:

- Validate the transparent boundary with Namada, which involves assets moving in or out of the pool.
- Validate shielded-to-shielded transactions within the MASP account, which don't move assets from the perspective of transparent Namada.
- Publishes the note commitment and nullifier reveal Merkle trees.

To validate, the MASP VP relies on the host environment. The host environment is the execution environment the Namada
ledger provides to the validity predicates. To the MASP VP it provides verification primitives, as the validations
described above take place as proofs verification (shielded-to-shielded) and transaction verification (transparent boundary).

## MASP VP Inputs
Along the ordinary inputs of VPs, the input to the VP is the following set of state changes:

- updates to the shielded pool's asset balances
- new encrypted notes
- updated note and nullifier tree states (partial, because Namada only stores the last block's anchor)

and the following data which is ancillary from the ledger's perspective:

- spend descriptions, which destroy old notes:
```
struct SpendDescription {
  // Value commitment to amount of the asset in the note being spent
  cv: jubjub::ExtendedPoint,
  // Last block's commitment tree root
  anchor: bls12_381::Scalar,
  // Nullifier for the note being nullified
  nullifier: [u8; 32],
  // Re-randomized version of the spend authorization key
  rk: PublicKey,
  // Spend authorization signature
  spend_auth_sig: Signature,
  // Zero-knowledge proof of the note and proof-authorizing key
  zkproof: Proof<Bls12>,
}
```
- output descriptions, which create new notes:
```
struct OutputDescription {
  // Value commitment to amount of the asset in the note being created
  cv: jubjub::ExtendedPoint,
  // Derived commitment tree location for the output note
  cmu: bls12_381::Scalar,
  // Note encryption public key
  epk: jubjub::ExtendedPoint,
  // Encrypted note ciphertext
  c_enc: [u8; ENC_CIPHERTEXT_SIZE],
  // Encrypted note key recovery ciphertext
  c_out: [u8; OUT_CIPHERTEXT_SIvpsZE],
  // Zero-knowledge proof of the new encrypted note's location
  zkproof: Proof<Bls12>,
}
```
Alongside the ordinary inputs that are common to all Namada VPs. The MASP specific inputs described are extracted from a
transaction data structure.

## Verifications

The VP must verify the proofs for all spend and output descriptions
([`bellman::groth16`](https://docs.rs/bellman/latest/bellman/groth16/index.html)), as well as the signature for spend notes.

Encrypted notes from output descriptions must be published in the storage so that holders of the viewing key can view them;
however, the VP does not concern itself with plaintext notes.

Nullifiers and commitments must be appended to their respective Merkle trees in the VP's storage as well, which is a
transaction-level rather than a block-level state update.

In addition to the individual spend and output description verifications, the final transparent asset value change
described in the transaction must equal the pool asset value change. As an additional sanity check, the pool's balance
of any asset may not end up negative.

NB: Shielded-to-shielded transactions in an asset do not, from the ledger's perspective, transact in that asset;
therefore, the asset's own VP cannot run as described above because the shielded pool is asset-hiding.

## Boundary Conditions
Below, the conditions necessary to maintain consistency between the MASP validity predicate ledger and Namada ledger are outlined.

|                  | is MASP VP                | is not MASP VP |
|------------------|--------------------------|---------------------------|
|**Target address**| no transparent outputs are permitted in the shielded transaction| there must be exactly one transparent output in the shielded transaction. Moreover the output: <br /><br />**public key** must be the hash of the target address bytes - this prevents replay attacks altering transfer destinations, the hash is specifically a RIPEMD-160 of a SHA-256 of the input bytes; <br /><br />**value** must equal that of the containing transfer - this prevents replay attacks altering transfer amounts; <br /><br />**asset type** must be derived from the token address raw bytes and the current epoch once Borsh serialized from the type `(Address, Epoch)`: the dependency on the address prevents replay attacks altering transfer asset types; the current epoch requirement prevents attackers from claiming extra rewards by forging the time when they began to receive rewards; the derivation must be done as specified in `0.3 Derivation of Asset Generator from Asset Identifier`|
|**Source address**| no transparent inputs are permitted in the shielded transaction. <br /><br />The transparent transaction value pool's: <br /><br />**amount** must equal the containing wrapper transaction's fee amount; <br /><br />**asset type** must be derived from the containing wrapper transaction's fee token, and the derivation must be done as specified in `0.3 Derivation of Asset Generator from Asset Identifier` | the transparent transaction value pool's amount must equal zero|

## Client capabilities
The client should be able to:
* Make transactions with a shielded sender and/or receiver
* Scan the blockchain to determine shielded assets in one's possession
* Generate payment addresses from viewing keys from spending keys

To make shielded transactions, the client has to be capable of creating and spending notes, and generating proofs which
the pool VP verifies.

Unlike the VP, which must have the ability to do complex verifications, the transaction code for shielded transactions
can be comparatively simple: it delivers the transparent value changes in or out of the pool, if any, and proof data
computed offline by the client.- Publishes the note commitment and nullifier reveal Merkle trees.

The client and wallet must be extended to support the shielded pool and the cryptographic operations needed to interact
with it. From the perspective of the transparent Namada protocol, a shielded transaction is just a data write to the
MASP storage, unless it moves value in or out of the pool. The client needs the capability to create notes, transactions,
and proofs of transactions, but it has the advantage of simply being able to link against the MASP crates, unlike the VP.
