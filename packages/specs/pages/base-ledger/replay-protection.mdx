# Replay Protection

Replay protection is a mechanism to prevent _replay attacks_, which consist of a
malicious user resubmitting an already executed transaction (often shortened to
"tx" in this document) to the ledger.

A replay attack causes the state of the machine to deviate from the intended one
(from the perspective of the parties involved in the original transaction) and
causes economic damage to the fee payer of the original transaction, who finds
themselves paying more than once. Further economic damage is caused if the
transaction involved the moving of value in some form (e.g. a transfer of
tokens) with the sender being deprived of more value than intended.

Since the original transaction was already well formatted for the protocol's
rules, the attacker doesn't need to rework it, making this attack relatively
easy.

Of course, a replay attack makes sense only if the attacker differs from the
_source_ of the original transaction, as a user will always be able to generate
another semantically identical transaction to submit without the need to replay
the same one.

To prevent this scenario, Namada supports a replay protection mechanism to
prevent the execution of already processed transactions.

## Context

This section illustrates the pre-existing context in the replay protection mechanims is implemented.

### Encryption-Authentication

The current implementation of Namada is built on top of CometBFT which
provides an encrypted and authenticated communication channel between every two
nodes to prevent a _man-in-the-middle_ attack (see the detailed {/* TODO: Fix link to be cometbft is possible*/}
[spec](https://github.com/cometbft/cometbft/blob/main/spec/p2p/legacy-docs/peer.md)).

The Namada protocol relies on this substrate to exchange transactions (messages)
that defines the state transition of the ledger. More specifically, a
transaction is composed of two parts: a `WrapperTx` and an inner `Tx`

{/* TODO: Check that this is up to date. I believe it is not */}
```rust
pub struct WrapperTx {
  /// The fee to be payed for including the tx
  pub fee: Fee,
  /// Used to determine an implicit account of the fee payer
  pub pk: common::PublicKey,
  /// The epoch in which the tx is to be submitted. This determines
  /// which decryption key will be used
  pub epoch: Epoch,
  /// Max amount of gas that can be used when executing the inner tx
  pub gas_limit: GasLimit,
  /// The optional unshielding tx for fee payment
  pub unshield: Option<Tx>,
  /// the encrypted payload
  pub inner_tx: EncryptedTx,
  /// sha-2 hash of the inner transaction acting as a commitment
  /// the contents of the encrypted payload
  pub tx_hash: Hash,
}

pub struct Tx {
  pub code: Vec<u8>,
  pub data: Option<Vec<u8>>,
  pub timestamp: DateTimeUtc,
}
```

The wrapper transaction is composed of some metadata, an optional unshielding tx
for fee payment (see [fee specs](../economics/fee-system.md)), the encrypted
inner transaction itself and the hash of the concatenation of these values. {/* TODO: Ensure that the hash of concatentation statement is as accurate as possible. It could be values, it could be the object (which consists of keys + values)*/}
The inner `Tx` transaction carries the Wasm code to be executed and the associated data.

A transaction is constructed as follows:

1. The struct `Tx` is produced
2. The hash of this transaction gets signed by the author, producing another
   `Tx` where the data field holds the concatenation of the original data and
   the signature (`SignedTxData`)
3. The produced transaction is encrypted and embedded in a `WrapperTx`. The
   encryption step exists for a future implementation of threshold decryption
   scheme (see [Ferveo](https://github.com/anoma/ferveo))
4. Finally, the `WrapperTx` is converted to a `Tx` struct, signed over its
   hash (same as step 2, relying on `SignedTxData`), and submitted to the
   network

Note that the signer of the `WrapperTx` and that of the inner one don't need to
coincide, but the signer of the wrapper will be charged with gas and fees. In
the execution steps:

1. The `WrapperTx` signature is verified and, only if valid, the tx is processed
2. In the following height the proposer decrypts the inner tx, checks that the
   hash matches that of the `tx_hash` field and, if everything went well,
   includes the decrypted tx in the proposed block
3. The inner tx will then be executed by the WASM runtime
4. After the execution, the affected validity predicates (also mentioned as VPs
   in this document) will check the storage changes and (if relevant) the
   signature of the transaction: if the signature is not valid, the VP will deem
   the transaction invalid and the changes won't be applied to the storage

The signature checks effectively prevent any tampering with the transaction data
because that would cause the checks to fail and the transaction to be rejected.
For a more in-depth view, please refer to the
[Namada execution spec](./execution.md).

### Tendermint replay protection

The underlying consensus engine,
[CometBFT](https://github.com/cometbft/cometbft/blob/main/spec/abci/abci%2B%2B_app_requirements.md#connection-state),
provides a first layer of protection in its mempool which is based on a cache of
previously seen transactions. This mechanism is actually aimed at preventing a
block proposer from including an already processed transaction in the next
block, which can happen when the transaction has been received late. Of course,
this also acts as a countermeasure against intentional replay attacks. This
check though, like all the checks performed in `CheckTx`, is weak, since a
malicious validator could always propose a block containing invalid
transactions. There's therefore the need for a more robust replay protection
mechanism implemented directly in the application.

## Implementation

Namada replay protection consists of three parts: the hash-based solution for
both `EncryptedTx` (also called the `InnerTx`) and `WrapperTx`, a way to
mitigate replay attacks in case of a fork and a concept of a lifetime for the
transactions.

### Hash register

The actual Wasm code and data for the transaction are encapsulated inside a
struct `Tx`, which gets encrypted as an `EncryptedTx` and wrapped inside a
`WrapperTx` (see the [relative](#encryption-authentication) section). This inner
transaction must be protected from replay attacks because it carries the actual
semantics of the state transition. Moreover, even if the wrapper transaction was
protected from replay attacks, an attacker could extract the inner transaction,
rewrap it, and replay it. Note that for this attack to work, the attacker will
need to sign the outer transaction himself and pay gas and fees for that, but
this could still cause much greater damage to the parties involved in the inner
transaction.

`WrapperTx` is the only type of transaction currently accepted by the ledger. It
must be protected from replay attacks because, if it wasn't, a malicious user
could replay the transaction as is. Even if the inner transaction implemented
replay protection or, for any reason, wasn't accepted, the signer of the wrapper
would still pay for gas and fees, effectively suffering economic damage.

To prevent the replay of both these transactions we will rely on a set of
already processed transactions' digests that will be kept in storage. These
digests will be computed on the **unsigned** transactions, to support replay
protection even for [multisigned](multisignature.md) transactions: in this case,
if hashes were taken from the signed transactions, a different set of signatures
on the same tx would produce a different hash, effectively allowing for a
replay. To support this, we'll first need to update the `WrapperTx` hash field
to contain the hash of the unsigned inner tx, instead of the signed one: this
doesn't affect the overall safety of Namada (since the wrapper is still signed
over all of its bytes, including the inner signature) and allows for early
replay attack checks in mempool and at wrapper block-inclusion time.
Additionally, we need a subspace in storage headed by a `ReplayProtection`
internal address:

```
/\$ReplayProtectionAddress/\$tx0_hash: None
/\$ReplayProtectionAddress/\$tx1_hash: None
/\$ReplayProtectionAddress/\$tx2_hash: None
...
```

The hashes will form the last part of the path to allow for a fast storage
lookup.

The consistency of the storage subspace is of critical importance for the
correct working of the replay protection mechanism. To protect it, a validity
predicate will check that no changes to this subspace are applied by any wasm
transaction, as those should only be available from protocol.

Both in `mempool_validation` and `process_proposal` we will perform a check
(together with others, see the [relative](#wrapper-checks) section) on both the
digests against the storage to check that neither of the transactions has
already been executed: if this doesn't hold, the `WrapperTx` will not be
included into the mempool/block respectively. In `process_proposal` we'll use a
temporary cache to prevent a replay of a transaction in the same block. If both
checks pass then the transaction is included in the block. The hashes are
committed to storage in `finalize_block` and the transaction is executed.

In the next block we deserialize the inner transaction, check the validity of
the decrypted txs and their correct order: if the order is off a new round of
CometBFT will start. If instead an error is found in any single decrypted tx,
we remove from storage the previously inserted hash of the inner tx to allow it
to be rewrapped, and discard the tx itself. Finally, in `finalize_block` we
execute the tx: if it runs out of gas then we'll remove its hash from storage,
again to allow rewrapping and executing the transaction, otherwise we'll keep
the hash in storage (both in case of success or failure of the tx).

#### Optional unshielding

The optional `unshield` field is supposed to carry an unshielding masp
`Transaction`. Given this assumption, there's no need to manage it since masp
has an internal replay protection mechanism.

Still, since this field represents a valid, `Transaction`, there is a possible
attack that can be run by leveraging this field: a malicious user could extract
this data before it makes it to a block, embedd it into a valid, masp signed
`Tx` and apply it in advance.

This attack is performed before the original tx is placed in a block and,
therefore, cannot be prevented with a replay protection mechanism. The only
result of this attack would be that the original wrapper transaction would fail
since it would attempt to replay a masp transfer: in this case, the submitter of
the original tx can recreate it without the need for the unshielding operation
since the attacker has already performed it.

Given that saving the hash of the unshielding transaction is redundant in case
of a proper masp transfer, Namada does not implement the replay protection
mechanism on the unshielding transaction, whose correctness is left to the masp
validity predicate. The combination of the fee system, the validity predicates
set and the protocol checks on the unshielding operation guarantees that even if
the attack explained in this section is performed:

- The original wrapper signer doesn't suffer economic damage (the wrapper
  containing the invalid unshielding forces the block rejection without fee
  collection)
- The attacker has to pay fees on the rewrapped tx preventing him to submit
  these transactions for free

#### Governance proposals

Governance [proposals](../base-ledger/governance.md) may carry some wasm code to
be executed in case the proposal passed. This code is embedded into a
`DecryptedTx` directly by the validators at block processing time and is not
inserted into the block itself.

Given that the wasm code is attached to the transaction initiating the proposal,
it could be extracted from here and inserted in a transaction before the
proposal is executed. Therefore, replay protection is not a solution to prevent
attacks on governance proposals' code. Instead, to protect these transactions,
Namada relies on its proposal id mechanism in conjunction with the VP set.

#### Protocol transactions

At the moment, protocol transactions are only used for ETH bridge related
operations. The current implementation already takes care of replay attempts by
keeping track of the validators' signature on the events: this also includes
replay attacks in the same block.

In the future, new types of protocol transactions may be supported: in this
case, a review of the replay protection mechanism might be required.

### Forks

In the case of a fork, the transaction hash is not enough to prevent replay
attacks. Transactions, in fact, could still be replayed on the other branch as
long as their format is kept unchanged and the counters in storage match.

To mitigate this problem, transactions will need to carry a `ChainId` identifier
to tie them to a specific fork. This field needs to be added to the `Tx` struct
so that it applies to both `WrapperTx` and `EncryptedTx`:

```rust
pub struct Tx {
  pub code: Vec<u8>,
  pub data: Option<Vec<u8>>,
  pub timestamp: DateTimeUtc,
  pub chain_id: ChainId
}
```

This new field will be signed just like the other ones and is therefore subject
to the same guarantees explained in the [initial](#encryption-authentication)
section. The validity of this identifier will be checked in `process_proposal`
for both the outer and inner tx: if a transaction carries an unexpected chain
id, it won't be applied, meaning that no modifications will be applied to
storage.

### Transaction lifetime

In general, a transaction is valid at the moment of submission, but after that,
a series of external factors (ledger state, etc.) might change the mind of the
submitter who's now not interested in the execution of the transaction anymore.

We have to introduce the concept of a lifetime (or timeout) for the
transactions: basically, the `Tx` struct will hold an optional extra field
called `expiration` stating the maximum `DateTimeUtc` up until which the
submitter is willing to see the transaction executed. After the specified time,
the transaction will be considered invalid and discarded regardless of all the
other checks.

By introducing this new field we are setting a new constraint in the
transaction's contract, where the ledger will make sure to prevent the execution
of the transaction after the deadline and, on the other side, the submitter
commits himself to the result of the execution at least until its expiration. If
the expiration is reached and the transaction has not been executed the
submitter can decide to submit a new transaction if he's still interested in the
changes carried by it.

In our design, the `expiration` will hold until the transaction is executed:
once it's executed, either in case of success or failure, the tx hash will be
written to storage and the transaction will not be replayable. In essence, the
transaction submitter commits himself to one of these three conditions:

- Transaction is invalid regardless of the specific state
- Transaction is executed (either with success or not) and the transaction hash
  is saved in the storage
- Expiration time has passed

The first condition satisfied will invalidate further executions of the same tx.

```rust
pub struct Tx {
  pub code: Vec<u8>,
  pub data: Option<Vec<u8>>,
  pub timestamp: DateTimeUtc,
  pub chain_id: ChainId,
  /// Optional lifetime of the transaction
  pub expiration: Option<DateTimeUtc>,
}
```

The wrapper transaction will match the `expiration` of the inner (if any) for a
correct execution. Note that we need this field also for the wrapper to
anticipate the check at mempool/proposal evaluation time, but also to prevent
someone from inserting a wrapper transaction after the corresponding inner has
expired forcing the wrapper signer to pay for the fees.

### Wrapper checks

In `mempool_validation` we will perform some checks on the wrapper tx to
validate it. These will involve:

- Signature
- `GasLimit` is below the block gas limit
- `Fees` are paid with an accepted token and match the minimum amount required
- `ChainId`
- Transaction hash
- Expiration
- Wrapper signer has enough funds to pay the fee
- Unshielding tx (if present), is indeed a masp unshielding transfer
- The unshielding tx (if present) releases the minimum amount of tokens required
  to pay fees
- The unshielding tx (if present) runs succesfully

For gas, fee and the unshielding tx more details can be found in the
[fee specs](../economics/fee-system.md).

These checks can all be done before executing the transactions themselves. If
any of these fails, the transaction should be considered invalid and the action
to take will be one of the followings:

1. If the checks fail on the signature, chainId, expiration, transaction hash,
   balance or the unshielding tx, then this transaction will be forever invalid,
   regardless of the possible evolution of the ledger's state. There's no need
   to include the transaction in the block. Moreover, we **cannot** include this
   transaction in the block to charge a fee (as a sort of punishment) because
   these errors may not depend on the signer of the tx (could be due to
   malicious users or simply a delay in the tx inclusion in the block)
2. If the checks fail on `Fee` or `GasLimit` the transaction should be
   discarded. In theory the gas limit of a block is a Namada parameter
   controlled by governance, so there's a chance that the transaction could
   become valid in the future should this limit be raised. The same applies to
   the token whitelist and the minimum fee required. However we can expect a
   slow rate of change of these parameters so we can reject the tx (the
   submitter can always resubmit it at a future time)

If instead all the checks pass validation we will include the transaction in the
block to store the hash and charge the fee.

All these checks are also run in `process_proposal`.

This mechanism can also be applied to another scenario. Suppose a transaction
was not propagated to the network by a node (or a group of colluding nodes).
Now, this tx might be valid, but it doesn't get inserted into a block. Without
an expiration, this tx can be replayed (better, applied, since it was never
executed in the first place) at a future moment in time when the submitter might
not be willing to execute it any more.

### Block rejection

To prevent a block proposer from including invalid transactions in a block, the
validators will reject the entire block in case they find a single invalid
wrapper transaction.

Rejecting the single invalid transaction while still accepting the block is not
a valid solution. In this case, in fact, the block proposer has no incentive to
include invalid transactions in the block because these would gain him no fees
but, at the same time, he doesn't really have a disincentive to not include
them, since in this case the validators will simply discard the invalid tx but
accept the rest of the block granting the proposer his fees on all the other
transactions. This, of course, applies in case the proposer has no other valid
tx to include. A malicious proposer could act like this to spam the block
without suffering any penalty.

To recap, a block is rejected when at least one of the following conditions is
met:

- At least one `WrapperTx` is invalid with respect to the checks listed in the
  [relative section](#wrapper-checks)
- The order/number of decrypted txs differs from the order/number committed in
  the previous block
